package jwtmodule

import (
	"crypto/rsa"
	"fmt"
	jwt "github.com/dgrijalva/jwt-go"
	"io/ioutil"
	"log"
	_ "os"
	_ "reflect"
)

const (
	privateKeyPath = "/home/jamesbondu/Desktop/developer-hub/Gogo/src/github.com/arujit/jwt/keys/private_key.pem"
	publicKeyPath  = "/home/jamesbondu/Desktop/developer-hub/Gogo/src/github.com/arujit/jwt/keys/public_key.pem"
)

type Keys struct {
	public  *rsa.PublicKey
	private *rsa.PrivateKey
}

var JWTMngr *Keys

func Initialize(path_params ...string) {
	var err error
	var public_path, private_path string
	var public, private []byte
	var public_key *rsa.PublicKey
	var private_key *rsa.PrivateKey

	if len(path_params) == 2 {
		public_path = path_params[0]
		private_path = path_params[1]
	} else {
		public_path = publicKeyPath
		private_path = privateKeyPath
	}
	private, err = ioutil.ReadFile(private_path)
	if err != nil {
		log.Fatal("Error reading private key")
	}

	private_key, _ = jwt.ParseRSAPrivateKeyFromPEM(private)
	public, err = ioutil.ReadFile(public_path)

	if err != nil {
		log.Fatal("Error reading public key")

	}

	public_key, _ = jwt.ParseRSAPublicKeyFromPEM(public)
	JWTMngr = &Keys{public: public_key, private: private_key}

}

func Encode(claims map[string]interface{}) string {

	claims_token := jwt.MapClaims(claims)
	token := jwt.NewWithClaims(jwt.SigningMethodRS512, claims_token)

	tokenString, err := token.SignedString(JWTMngr.private)
	if err != nil {
		log.Fatal("Error in Encoding claim")
	}
	return tokenString

}

func Decode(tokenString string) jwt.MapClaims {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
		}
		return JWTMngr.public, nil

	})

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		fmt.Println(claims)

	} else {
		fmt.Println(err)
	}

	claims, _ := token.Claims.(jwt.MapClaims)
	return claims

}
